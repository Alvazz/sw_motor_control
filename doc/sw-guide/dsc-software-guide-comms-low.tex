\section{Low Level Communications Interfaces}
This module provides a details on the low level (typically OSI levels 1-3) interfaces used in the XMOS Motor Control Development Platform.

\subsection{Ethernet Interface}

\subsection{MAC Layer}
The very low level Ethernet interface on the Motor Control Development Platform is implemented using the standard XMOS Ethernet MII and MAC software component.
The hardware interface is implemented using a SMSC LAN8710A 10/100 Ethernet MII PHY.

The original Ethernet component has been edited so that it uses a channel to signal that the reset of the MII PHY is required, rather than signaling it over a actual pin.
The shared IO manager takes this channel and controls the appropriate pin of a shared 4-bit port.

The MAC address is programmed into the OTP of all XCores on the Motor Control Development Platform, in the form 00:22:97:00:4X:XX, where X:XX are the last 3 digits of the serial number encoded as hexadecimal.

Further details will not be included as this software component is documented elsewhere.


\subsection{TCP/IP}

The middle layer of the Ethernet interface is the standard XMOS TCP/IP, which is a port of the open-source uIP TCP/IP stack designed for microcontrollers.
It features a small memory footprint, whilst at the same time enabling high data throughputs if used correctly.
As it only has a sliding window size of 1, the data rate when talking to Windows based PCs can be very low due to the use of delayed ACKs.
The connection must be shutdown and re-establish each time or ACKs must be forced by sending packets back to the board to prevent this problem.

The TCP/IP stack runs on XCore 0, where there is plenty of available MIPS and memory.
It is called from main via a wrapper function that either sets the IP address of the board or configures the TCP/IP stack to use DHCP.
This is controlled by the USE\_DHCP define.


\subsection{CAN Interface}

The CAN Medium Access Control (MAC) interface to the bus is provided by the XMOS CAN software component thread on XCore 1.
The physical (PHY) interface for the CAN bus is provided by a Maxim MAX3059 CAN transceiver.

The MAC also implements the Logical Link Control (LLC) sublayer of the CAN bus, handles errors, as well as providing functions to send and receive packets on the bus.
Bit errors, stuffing errors, form errors and CRC errors are all detected.
All invalid packets are simply discarded when received.
Errors on transmission cause it to retry the transmission.

For the maximum possible throughput of 1Mbps the thread requires 100MIPS of processing, but due to the 7 other threads running on this core this is not possible.
The thread gets a maximum of 62.5MIPS and can therefore run the bus at 500Kbps.
The CAN baud rate is set by setting the define "BAUD\_RATE" in CanIncludes.h header file to the required rate in bits per second.

Separate channels are provided for the client to send and receive communications on the CAN interface. 
The prototype for the CAN MAC is provided below:

\begin{lstlisting}
void canPhyRxTx(chanend rxChan, chanend txChan, clock clk, buffered in port:32 canRx, port canTx);
\end{lstlisting}


\subsubsection{Client Interface}

The following functions are available to a client thread to allow it to interact with the CAN MAC:

\begin{itemize}
\item sendPacket(chanend c, struct CanPacket \&p) - non-blocking call to send a packet on the bus.
\item receivePacket(chanend c, struct CanPacket \&p) - blocking call to receive a packet from the bus.
\item printPacket(struct CanPacket \&p) - prints a packet out on the debug interface.
\item initPacket(struct CanPacket \&p) - initiates a packet.
\item randomizePacket(struct CanPacket \&p, int bitZero) - fills a packet with random data.
\end{itemize}
